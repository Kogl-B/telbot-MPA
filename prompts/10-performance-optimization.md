# 10 — Оптимизация производительности

> **Аннотация:** Промпт для анализа и оптимизации медленного кода. Определяет узкие места, предлагает оптимизации, ранжированные по эффекту, и предоставляет оптимизированный код с оценкой улучшения.

## Когда использовать

- Код работает медленно
- Высокое потребление памяти / CPU
- Нужно обработать больше данных
- Подготовка к масштабированию

---

## Промпт

```
# Роль
Ты — Performance Engineer, специализирующийся на оптимизации ${language}.

# Медленный код
Файл: ${filePath}
```
${code}
```

# Метрики
- Текущая производительность: ${currentPerformance}
- Целевая производительность: ${targetPerformance}
- Объём данных: ${dataVolume}
- Ограничения: ${constraints} (память / CPU / сеть / время)

# Контекст
- Как часто вызывается: ${callFrequency}
- Профиль нагрузки: ${loadProfile} (burst / steady / batch)
- Что уже пробовали: ${triedOptimizations}

# Проанализируй

## Алгоритмическая сложность
- Текущая Big-O для каждой ключевой операции
- Можно ли улучшить?

## Узкие места
- Где тратится больше всего времени?
- Есть ли N+1 запросы к БД?
- Лишние вычисления / аллокации?
- Блокирующие операции?

## Оптимизации (ранжировано по эффекту)
Для каждой:
1. Что оптимизировать
2. Почему это медленно
3. Оптимизированный код
4. Оценка улучшения (x2 / x10 / ...)
5. Компромиссы (читаемость, память, сложность)

# Формат вывода
## Анализ узких мест
[таблица: место → причина → влияние]

## Оптимизации (от большего эффекта к меньшему)
### 1. [Название]
- Эффект: ~${X}x ускорение
- Код до → после
- Компромисс: [что теряем]

## Итог
- Ожидаемая производительность после всех оптимизаций
- Что делать, если этого недостаточно (кэш, очередь, архитектура)
```

---

## Ожидаемый результат

- Определение узких мест с обоснованием
- Оптимизированный код
- Оценка прироста производительности
- Архитектурные рекомендации для масштабирования

## Советы

- По возможности прикладывайте результаты профайлера
- Укажите реальный объём данных и паттерн нагрузки
- Для БД-запросов: включайте схему таблиц и индексы

## Роль в агентной системе

Sub-Agent Coding Agent'a. Используется при обнаружении проблем производительности.
**Prompt Chaining**: Профилирование → Анализ (10) → Оптимизация → Тесты (12) → Повторный профиль

## ⚠️ Антипаттерны

- **Assumption Trap**: "Это медленно" без профилера → сначала измерь
- **Trust Everything**: Оптимизировал без бенчмарка → до/после обязательно
- **CoT**: Для анализа сложности — думай пошагово: Big O каждой операции
